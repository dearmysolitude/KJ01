## 문제

재귀적인 패턴으로 별을 찍어보자. N이 3의 거듭제곱이라고 할 때, 크기 N의 패턴은 NXN 정사각형 모양이다.

N은 $3^k$이며, $1 <= k <$ 8이다.

### 예시

N = $3$

```
***
* *
***
```

N = $3^3$

```
***************************
* ** ** ** ** ** ** ** ** *
***************************
***   ******   ******   ***
* *   * ** *   * ** *   * *
***   ******   ******   ***
***************************
* ** ** ** ** ** ** ** ** *
***************************
*********         *********
* ** ** *         * ** ** *
*********         *********
***   ***         ***   ***
* *   * *         * *   * *
***   ***         ***   ***
*********         *********
* ** ** *         * ** ** *
*********         *********
***************************
* ** ** ** ** ** ** ** ** *
***************************
***   ******   ******   ***
* *   * ** *   * ** *   * *
***   ******   ******   ***
***************************
* ** ** ** ** ** ** ** ** *
***************************
```

## 풀이

- 재귀로 접근
- 3의 거듭 제곱으로 별이 찍히므로 조그마한 상자(3X3) 짜리가 생성되면 이것을 다시 3X3 찍어낸다.
- 이 과정을 반복

## 오답 코드

- 처음에 이렇게 작성하였는데, 이런 식으로 작동하면 하나의 상자는 제대로 출력이 되나, 상자를 여러 개를 수평으로 쌓을 수 없다. 출력이 1 row 씩 되기 때문에 하나의 박스를 출력하고 다음 줄로 넘어가면 수평으로 출력시킬 수 없기 때문이다.
- 의도대로 출력하려면 어떻게 출력할 지 정보를 가진 채로 처음부터 모조리 출력을 해야한다.

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N = int(input())

def printAStar(j):
    if j == 2:
        print("*")
    else:
        print("*", end = "")

def printABlank():
    print(" ", end = "")

def makeBox(n):
    n = n//3
    box = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
    for i in range(0, 3):
        for j in range(0, 3):
            if box[i][j] == 1:
                if(n != 1):
                    makeBox(n)
                else:
                    printAStar(j)
            else:
                if(n != 1):
                    for l in range(n):
                        for m in range(n):
                            printABlank()
                            print()
                else:
                    printABlank()


makeBox(N)
```

## 해결?

- 출력할 크기의 좌표를 나타내는 2 차원 배열을 만들었다.
- 재귀적으로 원소에 접근하여 출력할지 결정하는 플래그로 사용하기로 하였다.
- 그렇다면 어떤식으로 원소에 접근해야 할까
    - 분할 정복/재귀인 것은 당연하다.
    - 소거법으로, 필요없는 부분을 0으로 바꾸자
    - 예제로 출력되어 있는 결과물을 살펴보면, 규칙을 확인할 수 있다.
- 규칙
    - 단계별로 나누어 살펴보자: 그림이 도움이 된다.
    - 가장 큰 사각형(27X27)에서 한 단계 낮은 단계인 9X9 짜리 사각형이 가운데에 비어있다: 9X9짜리 사각형 1 개, (9 + 1, 9 + 1) ~ (9 + 9, 9 + 9)
    - 그 다음 스케일(9X9) 수준에서는 한 단계 낮은 단계인 3X3 짜리 사각형이 9X9 사각형의 가운데에 하나 비어있다: (3X3) 사각형 9 개, (3 + 1, 3 + 1) ~ (3 + 3, 3 + 3), (1 + 3 + 9, 3 + 1) ~ (, )...
    - 마지막은 (3X3) 사각형 안에 (1X1) 자리 사각형이 가운데 비어있다: (1X1) 사각형 81 개, (1 + 1, 1 + 1), (1 + 3, 1), (1, 1 + 3), ...
- 상위 사각형에서 지워지는 부분에 대해서 하위 부분은 신경 쓸 필요가 없다.

큰 사각형부터 지워나가려고 했으나 코드가 복잡해져 일정 수준 이상 손대기가 어려웠다: 더 쉬운 방법이 있을 것이다.

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)

N = int(input())
Flags = [ [ 1 for _ in range(N) ] for _ in range(N) ]

def findZero(flags, n, repeat):
    if(n == 1):
        
        return

    tmp = n//3
    
    for k in range(repeat):
        for l in range(repeat):
            for i in range((k + 1) * tmp + 1, (k + 2) * tmp+1):
                for j in range((l + 1) * tmp + 1, (l + 2) * tmp+1):
                    flags[i][j] = 0
                    print(i, j, ": done")
    findZero(flags, tmp, 3 * repeat)

findZero(Flags, N, 1)

for i in range(N):
    for j in range(N):
        if(Flags[i][j] == 1):
            print("*", end = "")
        else:
            print(" ", end = "")
    print("")
```

## 해결!

별을 만들어내 2 차원 배열에 붙여넣는 방법을 사용한다.재귀로 매우 간단하게 구현할 수 있다!

- 문자열 '*' * 3 의 결과는 '***' 이다: 리스트를 곱한게 아니라 요소 문자를 곱한거다. 
- `print('\n'.join(append_star(n)))` 에서 join은 리스트에 있는 요소를 하나하나 합쳐 문자열로 바꾸고, '\n'을 사이에 둔다.
- 이전 단위의 별이 같은 방식으로 형태가 커지기 때문에 이전에 사용한 별을 재귀로 사용할 수 있다: 맨 윗줄은 이전 단위가 3개/중간 줄은 하나 바고 둘로 감싸고/아랫 줄도 단위가 3개 반복되는 형식.

이전 단계의 별 S는 그 단계의 열을 요소로 가지는 리스트로 구성되어 있다.
- 가장 윗줄은 3배 늘어나고
- 중간 줄은 (현재 단계)//3 만큼 비도록 하고 이전 단계 S로 감
- 마지막 줄도 3배 늘어난다.